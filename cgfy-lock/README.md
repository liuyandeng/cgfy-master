# 锁

## 介绍
- [redisson](https://github.com/redisson/redisson/wiki/%E7%9B%AE%E5%BD%95)
- java
- sql


## 线程同步:synchronized
 /ˈsɪŋkrənaɪzd/ 
 
 synchronized是Java中的关键字，是一种同步锁。它修饰的对象有以下几种： 
 
- 修饰一个代码块，被修饰的代码块称为同步语句块，其作用的范围是大括号{}括起来的代码，作用的对象是调用这个代码块的对象； 
- 修饰一个方法，被修饰的方法称为同步方法，其作用的范围是整个方法，作用的对象是调用这个方法的对象； 
- 修改一个静态的方法，其作用的范围是整个静态方法，作用的对象是这个类的所有对象； 
- 修改一个类，其作用的范围是synchronized后面括号括起来的部分，作用主的对象是这个类的所有对象。

[![avatar](http://liuyandeng.gitee.io/gitpages/img/lock/java/synchronized.png)](https://www.jianshu.com/p/d53bf830fa09)
### 为什么要使用synchronized
在并发编程中存在线程安全问题，主要原因有：1.存在共享数据 2.多线程共同操作共享数据。
关键字synchronized可以保证在同一时刻，只有一个线程可以执行某个方法或某个代码块，同时synchronized可以保证一个线程的变化可见（可见性）。
### 实现原理
synchronized可以保证方法或者代码块在运行时，同一时刻只有一个方法可以进入到临界区，同时它还可以保证共享变量的内存可见性
### synchronized的作用
Synchronized是Java中解决并发问题的一种最常用最简单的方法 ，他可以确保线程互斥的访问同步代码
### 修饰一个方法
Synchronized修饰一个方法很简单，就是在方法的前面加synchronized，public synchronized void method(){}; synchronized修饰方法和修饰一个代码块类似，
只是作用范围不一样，修饰代码块是大括号括起来的范围，而修饰方法范围是整个函数。如将的run方法改成如下的方式，实现的效果一样。

    public synchronized void run() {
           {
                for (int i = 0; i < 5; i++) {
                    try {
                        System.out.println("线程名:"+Thread.currentThread().getName() + ":" + (count++));
                        Thread.sleep(100);
                    } catch (InterruptedException e) {
                        e.printStackTrace();
                    }
                }
            }
        }
Synchronized作用于整个方法的写法。

写法一:
    
     public synchronized void method()
     {
        // todo
     }

写法二:

    public void method()
    {
       synchronized(this) {
          
       }
    }
写法一修饰的是一个方法，写法二修饰的是一个代码块，但写法一与写法二是等价的，都是锁定了整个方法时的内容。

在用synchronized修饰方法时要注意以下几点： 

- synchronized关键字不能继承。 

虽然可以使用synchronized来定义方法，但synchronized并不属于方法定义的一部分，因此，synchronized关键字不能被继承。如果在父类中的某个方法使用了synchronized关键字，
而在子类中覆盖了这个方法，在子类中的这个方法默认情况下并不是同步的，而必须显式地在子类的这个方法中加上synchronized关键字才可以。
当然，还可以在子类方法中调用父类中相应的方法，这样虽然子类中的方法不是同步的，但子类调用了父类的同步方法，因此，子类的方法也就相当于同步了。这两种方式的例子代码如下： 
在子类方法中加上synchronized关键字

    class Parent {
       public synchronized void method() { }
    }
    class Child extends Parent {
       public synchronized void method() { }
    }

在子类方法中调用父类的同步方法

    class Parent {
       public synchronized void method() {   }
    }
    class Child extends Parent {
       public void method() { super.method();   }
    }
在定义接口方法时不能使用synchronized关键字。构造方法不能使用synchronized关键字，但可以使用synchronized代码块来进行同步。

### 修饰一个静态的方法
Synchronized也可修饰一个静态方法，用法如下：

    public synchronized static void method() {
       
    }
我们知道静态方法是属于类的而不属于对象的。同样的，synchronized修饰的静态方法锁定的是这个类的所有对象。

### 修饰一个类
效果和synchronized修饰静态方法是一样的，synchronized作用于一个类T时，是给这个类T加锁，T的所有对象用的是同一把锁。

[总结](https://www.cnblogs.com/weibanggang/p/9470718.html):

- 无论synchronized关键字加在方法上还是对象上，如果它作用的对象是非静态的，则它取得的锁是对象；
如果synchronized作用的对象是一个静态方法或一个类，则它取得的锁是对类，该类所有的对象同一把锁。 
- 每个对象只有一个锁（lock）与之相关联，谁拿到这个锁谁就可以运行它所控制的那段代码。 
- 实现同步是要很大的系统开销作为代价的，甚至可能造成死锁，所以尽量避免无谓的同步控制


 
 
1.为什么要使用synchronized

在并发编程中存在线程安全问题，主要原因有：
- 1.存在共享数据 
- 2.多线程共同操作共享数据。

关键字synchronized可以保证在同一时刻，只有一个线程可以执行某个方法或某个代码块，同时synchronized可以保证一个线程的变化可见（可见性），即可以代替volatile。

## 多线程
最近手上拿到一个程序，其中是一个视频监控的小程序，其中调用了线程，但是调试的时候出现的BUG，调试了N久，无果。最后，我把线程函数用一个普通的函数替代了，
就没有错误了，后来，变思索，此处为何要用线程，不用不行吗？调用线程的有何优点？何时适用？

CPU是以时间片的方式为进程分配CUP处理时间的，当一个进程以同步的方式去完成几件事情时，此进程必须完成了第一件事情以后再做第二件事，如此按顺序地向CPU请求完成要做的事情。
在此单线程的工作模式下，如果把CUP看作是一共有100个时间片的话，CPU可能一直都只是花了其中的10个时间片来处理当前进程所要做的事情，只是用到了CPU的10%的时间片，
而其他时间都白白浪费了，当然，实际上CPU的工作模式还是做完一件事以后再去做另一件事，只是CUP的处理速度非常快，很快就处理完成所请求的情事。

为了提高CPU的使用率，采用多线程的方式去同时完成几件事情而互不干扰，如当前进程要完成三件事情1、2、3，那么CPU会分别用10%的时间来同时处理这3件事情，
从而让CPU的使用率达到了30%，大大地提高了CPU的利用率。多线程的好处在处理一些特殊的场合其优势尤其明显。比如下载文件，你要一边下载一边显示进度一边保存，
在这种情况下，如果没有用多线程的话，没有意外的话一般都会把主线程阻塞，比如进度条的进度根本没有随着已下载的量而变化，堪至是整个窗体都动不了，
用多线程就可以很好地解决这个问题。

这里有一个生活实例可能更好地去理解多线程：回去看你女朋友做饭，正常的话她都会把洗好的菜（肉）先放到锅里煮，然后一边洗别的菜或处理别的事情，
如：洗碗、收拾桌台准备开饭，人还是一个人，但她同时做几件事情，这样就可以大大地提高效率。总的一句话就是：CPU还是要花同样多的时间去完成所有的事情，
但多线程可以让CPU掺插地同时做多件事情，在视觉上让用户觉得计算机在同时帮他处理多件事情，更好地改善用户体验。

了解了多线程的好处以后，就要了解应该在什么样的情况下使用多线程技术。因为并不是说所有情况下用多线程都是好事，因为多线程的情况下，
CPU还要花时间去维护，CPU处理各线程的请求时在线程间的切换也要花时间，所以一般情况下是可以不用多线程的，用了有时反而会得不偿失。
多线程可以很大程度的提高计算机系统的利用效率,大多情况下，要用到多线程的主要是需要处理大量的IO操作时或处理的情况需要花大量的时间等等，比如：读写文件、视频图像的采集、处理、显示、保存,迅雷下载等。

何时使用多线程技术,何时避免用它,是我们需要掌握的重要课题。多线程技术是一把双刃剑,在使用时需要充分考虑它的优缺点。

多线程处理可以同时运行多个线程。多线程应用程序将程序划分成多个独立的任务

是否需要创建多个线程取决于各种因素。在以下情况下,最适合采用多线程处理: 

- 耗时或大量占用处理器的任务阻塞用户界面操作
- 各个任务必须等待外部资源 (如远程文件或 Internet连接)

### 优点：
- 多线程技术使程序的响应速度更快 ,因为用户界面可以在进行其它工作的同时一直处于活动状态;
- 当前没有进行处理的任务时可以将处理器时间让给其它任务;
- 占用大量处理时间的任务可以定期将处理器时间让给其它任务;
- 可以随时停止任务;
- 可以分别设置各个任务的优先级以优化性能。

### 缺点
同样的 ,多线程也存在许多缺点 ,在考虑多线程时需要进行充分的考虑。多线程的主要缺点包括: 

- 等候使用共享资源时造成程序的运行速度变慢。这些共享资源主要是独占性的资源 ,如打印机等。
- 对线程进行管理要求额外的 CPU开销。线程的使用会给系统带来上下文切换的额外负担。当这种负担超过一定程度时,多线程的特点主要表现在其缺点上,比如用独立的线程来更新数组内每个元素。
- 线程的死锁。即较长时间的等待或资源竞争以及死锁等多线程症状。
- 对公有变量的同时读或写。当多个线程需要对公有变量进行写操作时,后一个线程往往会修改掉前一个线程存放的数据,从而使前一个线程的参数被修改;另外 ,当公用变量的读写操作是非原子性时,在不同的机器上,中断时间的不确定性,会导致数据在一个线程内的操作产生错误,从而产生莫名其妙的错误,而这种错误是程序员无法预知的。


### 创建线程
创建线程的两个方法,一个实现继承Thread类,一个实现Runnable接口,所有的线程要执行的操作代码都需要写在run()方法中,并通过start()方法年启动线程.

### 线程的状态
一个正在运行的线程因为某种原因不能继续运行时进入阻塞状态,即不可运行的状态,调用thread方法的sleep()方法可使线程进入不可运行的状态.

### 线程调度
当同一时刻有多个线程处于可运行状态,他们需要排队等待CPU资源,每个线程自动获得一个线程的优先级,优先级的高低放映线程的重要或紧急程度,可运行状态的线程按优先级排队,线程调度依据优先级基础上的”先到先服务”的原则.

线程调度管理器负责线程排队和CPU在线程间的分配,并按线程调度算法进行调度,当线程调度管理器选中某个线程时,该线程获得CPU资源进入可运行状态,

线程调度室抢占调度,即如果在当前线程执行过程中一个更高级优先级的线程进入可运行状态,则这个更高优先级的宣称立即调度执行.进行调度的方法join,sleep,yield(),setPriority方法进行优先级设置


### 线程同步
当一些同时运行的线程需要共享数据此时需要考虑其他线程的状态和行为,否者不能保证程序运行的结果的正确性.比如同一银行账户的多个取款卡,当两个或多个线程需要访问同一资源时需要某种顺序来确保该资源同一时刻只能被一个线程使用的方式称为线程同步.

使用关键字synchronized实现,被他修饰的方法或代码块其实就是在该方法或代码块里加一把锁,其所声明的方法只能有一个处于可执行状态

    
### 线程间通信
在很多现实问题中要求不仅要同步访问同一共享资源,而且线程间还彼此牵制,相互通信和依赖.建立在同步的基础上,实现不同线程之间的消息传递方法有wait(),notify().

    Wait()退出运行态，放弃资源锁，进入到等待队列
    Notify()从等待序列中唤起一个线程

